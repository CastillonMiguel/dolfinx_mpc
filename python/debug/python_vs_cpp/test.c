// This code conforms with the UFC specification version 2018.2.0.dev0
// and was automatically generated by FFCX version 2019.2.0.dev0.
//
// This code was generated with the following parameters:
//
//  {'epsilon': 1e-14,
//   'external_includes': '',
//   'precision': -1,
//   'quadrature_degree': -1,
//   'quadrature_rule': 'auto',
//   'representation': 'auto',
//   'scalar_type': 'double',
//   'tabulate_tensor_void': False}


typedef double ufc_scalar_t;
#include <math.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <ufc.h>

// Code for element element_e62ea130829c4611b756de2cbd7d0ee4b144b528

int value_dimension_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(int i)
{
  return 1;
}

int reference_value_dimension_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(int i)
{
  return 1;
}

int evaluate_reference_basis_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
for (int k = 0; k < num_points * 4; ++k)
    reference_values[k] = 0.0;
for (int ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (((2.0 + 2.0 * Y[0]) + Y[1]) + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 * ((2.0 + 3.0 * Y[1]) + Y[2])) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Accumulate products of coefficients and basisvalues
    for (int r = 0; r < 4; ++r)
        reference_values[4 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[4 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[4 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[4 * ip + 3] += coefficients3[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(reference_values, num_points, X);
const int num_derivatives = pow(3, order);
for (int l0 = 0; l0 < (num_points * 4) * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][4][4] =
    { { { 0.0, 0.0, 0.0, 0.0 },
        { 6.324555320336758, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 5.477225575051663, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0 },
        { 5.163977794943224, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
const int reference_offset[4] = { 0 };
const int num_components[4] = { 1, 1, 1, 1 };
// Precomputed combinations
const int combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (((2.0 + 2.0 * Y[0]) + Y[1]) + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 * ((2.0 + 3.0 * Y[1]) + Y[2])) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Loop over all dofs
    for (int i = 0; i < 4; ++i)
    {
        double derivatives[3] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        }
        for (int r = 0; r < num_derivatives; ++r)
            for (int c = 0; c < num_components[i]; ++c)
                reference_values[(((4 * num_derivatives) * ip + num_derivatives * i) + r) + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    const uint32_t cell_permutation)
{
  const int num_derivatives = pow(3, order);
// Precomputed combinations
const int combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int l = 0; l < (num_points * 4) * num_derivatives; ++l)
    values[l] = 0.0;
const int reference_offsets[4] = { 0 };
const int physical_offsets[4] = { 0 };
for (int ip = 0; ip < num_points; ++ip)
{
    double transform[3][3];
    for (int r = 0; r < num_derivatives; ++r)
        for (int s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int r = 0; r < num_derivatives; ++r)
        for (int s = 0; s < num_derivatives; ++s)
            for (int k = 0; k < order; ++k)
                transform[r][s] *= K[((3 * 3) * ip + 3 * combinations[order - 1][s][k]) + combinations[order - 1][r][k]];
    for (int d = 0; d < 4; ++d)
    {
        for (int s = 0; s < num_derivatives; ++s)
        {
            for (int i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[(((4 * num_derivatives) * ip + num_derivatives * d) + s) + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int r = 0; r < num_derivatives; ++r)
                    values[(((4 * num_derivatives) * ip + num_derivatives * d) + r) + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(
     ufc_scalar_t* restrict reference_values,
     const ufc_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     const ufc_coordinate_mapping* restrict cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[1];
reference_values[2] = physical_values[2];
reference_values[3] = physical_values[3];
return 0;
}

int tabulate_reference_dof_coordinates_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(double* restrict reference_dof_coordinates)
{
  static const double dof_X[12] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 12*sizeof(double));
return 0;
}


ufc_finite_element* create_sub_element_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(int i)
{
  return NULL;
}

ufc_finite_element* create_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(void)
{
  ufc_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Lagrange', tetrahedron, 1)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 4;
  element->value_rank = 0;
  element->value_dimension = value_dimension_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->reference_value_size = 1;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->transform_values = transform_values_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  element->create = create_element_e62ea130829c4611b756de2cbd7d0ee4b144b528;

  return element;
}

// End of code for element element_e62ea130829c4611b756de2cbd7d0ee4b144b528

// Code for element element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f

int value_dimension_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
for (int k = 0; k < (num_points * 12) * 3; ++k)
    reference_values[k] = 0.0;
for (int ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (((2.0 + 2.0 * Y[0]) + Y[1]) + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 * ((2.0 + 3.0 * Y[1]) + Y[2])) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Accumulate products of coefficients and basisvalues
    for (int r = 0; r < 4; ++r)
        reference_values[(12 * 3) * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[(12 * 3) * ip + 3] += coefficients1[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[(12 * 3) * ip + 3 * 2] += coefficients2[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[(12 * 3) * ip + 3 * 3] += coefficients3[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 4) + 1] += coefficients0[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 5) + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 6) + 1] += coefficients2[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 7) + 1] += coefficients3[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 8) + 2] += coefficients0[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 9) + 2] += coefficients1[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 10) + 2] += coefficients2[0][r] * basisvalues1[r];
    for (int r = 0; r < 4; ++r)
        reference_values[((12 * 3) * ip + 3 * 11) + 2] += coefficients3[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(reference_values, num_points, X);
const int num_derivatives = pow(3, order);
for (int l0 = 0; l0 < ((num_points * 12) * num_derivatives) * 3; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][4][4] =
    { { { 0.0, 0.0, 0.0, 0.0 },
        { 6.324555320336758, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 5.477225575051663, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0 },
        { 5.163977794943224, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
const int reference_offset[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
const int num_components[12] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// Precomputed combinations
const int combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (((2.0 + 2.0 * Y[0]) + Y[1]) + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 * ((2.0 + 3.0 * Y[1]) + Y[2])) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Loop over all dofs
    for (int i = 0; i < 12; ++i)
    {
        double derivatives[3] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 6:
            // Compute reference derivatives for dof 6.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 7:
            // Compute reference derivatives for dof 7.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 8:
            // Compute reference derivatives for dof 8.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 9:
            // Compute reference derivatives for dof 9.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 10:
            // Compute reference derivatives for dof 10.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 11:
            // Compute reference derivatives for dof 11.
            for (int r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int l0 = 0; l0 < 4; ++l0)
                        for (int l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int t = 0; t < 4; ++t)
                        for (int u = 0; u < 4; ++u)
                            for (int tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int s = 0; s < 4; ++s)
                    for (int t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        }
        for (int r = 0; r < num_derivatives; ++r)
            for (int c = 0; c < num_components[i]; ++c)
                reference_values[(((12 * (num_derivatives * 3)) * ip + (num_derivatives * 3) * i) + 3 * r) + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    const uint32_t cell_permutation)
{
  const int num_derivatives = pow(3, order);
// Precomputed combinations
const int combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int l = 0; l < ((num_points * 12) * num_derivatives) * 3; ++l)
    values[l] = 0.0;
const int reference_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
const int physical_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
for (int ip = 0; ip < num_points; ++ip)
{
    double transform[3][3];
    for (int r = 0; r < num_derivatives; ++r)
        for (int s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int r = 0; r < num_derivatives; ++r)
        for (int s = 0; s < num_derivatives; ++s)
            for (int k = 0; k < order; ++k)
                transform[r][s] *= K[((3 * 3) * ip + 3 * combinations[order - 1][s][k]) + combinations[order - 1][r][k]];
    for (int d = 0; d < 12; ++d)
    {
        for (int s = 0; s < num_derivatives; ++s)
        {
            for (int i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[(((12 * (num_derivatives * 3)) * ip + (num_derivatives * 3) * d) + 3 * s) + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int r = 0; r < num_derivatives; ++r)
                    values[(((12 * (num_derivatives * 3)) * ip + (num_derivatives * 3) * d) + 3 * r) + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(
     ufc_scalar_t* restrict reference_values,
     const ufc_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     const ufc_coordinate_mapping* restrict cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[3];
reference_values[2] = physical_values[6];
reference_values[3] = physical_values[9];
reference_values[4] = physical_values[13];
reference_values[5] = physical_values[16];
reference_values[6] = physical_values[19];
reference_values[7] = physical_values[22];
reference_values[8] = physical_values[26];
reference_values[9] = physical_values[29];
reference_values[10] = physical_values[32];
reference_values[11] = physical_values[35];
return 0;
}

int tabulate_reference_dof_coordinates_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(double* restrict reference_dof_coordinates)
{
  static const double dof_X[36] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 36*sizeof(double));
return 0;
}

ufc_finite_element* create_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(void);

ufc_finite_element* create_sub_element_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(int i)
{
  switch (i)
{
case 0:
    return create_element_e62ea130829c4611b756de2cbd7d0ee4b144b528();
case 1:
    return create_element_e62ea130829c4611b756de2cbd7d0ee4b144b528();
case 2:
    return create_element_e62ea130829c4611b756de2cbd7d0ee4b144b528();
default:
    return NULL;
}
}

ufc_finite_element* create_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(void)
{
  ufc_finite_element* element = malloc(sizeof(*element));

  element->signature = "VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 12;
  element->value_rank = 1;
  element->value_dimension = value_dimension_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->value_size = 3;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->reference_value_size = 3;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->transform_values = transform_values_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->num_sub_elements = 3;
  element->create_sub_element = create_sub_element_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  element->create = create_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;

  return element;
}

// End of code for element element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f

// Code for dofmap dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528

void tabulate_entity_dofs_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    case 3:
        dofs[0] = 3;
        break;
    }
    break;
}
}


ufc_dofmap* create_sub_dofmap_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528(int i)
{
return NULL;
}

ufc_dofmap* create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528(void)
{
  ufc_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFCX dofmap for FiniteElement('Lagrange', tetrahedron, 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 4;
  dofmap->num_entity_dofs[0] = 1;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  dofmap->create = create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528;

  dofmap->size_base_permutations = 56;
  static const int bp[56] = {0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3};
  dofmap->base_permutations = bp;


  return dofmap;
}

// End of code for dofmap dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528

// Code for dofmap dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f

void tabulate_entity_dofs_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 4;
        dofs[2] = 8;
        break;
    case 1:
        dofs[0] = 1;
        dofs[1] = 5;
        dofs[2] = 9;
        break;
    case 2:
        dofs[0] = 2;
        dofs[1] = 6;
        dofs[2] = 10;
        break;
    case 3:
        dofs[0] = 3;
        dofs[1] = 7;
        dofs[2] = 11;
        break;
    }
    break;
}
}

ufc_dofmap* create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528(void);

ufc_dofmap* create_sub_dofmap_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(int i)
{
switch (i)
{
case 0:
    return create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528();
case 1:
    return create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528();
case 2:
    return create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528();
default:
    return NULL;
}
}

ufc_dofmap* create_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(void)
{
  ufc_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFCX dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 12;
  dofmap->num_entity_dofs[0] = 3;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  dofmap->num_sub_dofmaps = 3;
  dofmap->create_sub_dofmap = create_sub_dofmap_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
  dofmap->create = create_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;

  dofmap->size_base_permutations = 168;
  static const int bp[168] = {0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9,10,11};
  dofmap->base_permutations = bp;


  return dofmap;
}

// End of code for dofmap dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f

// Code for coordinate mapping coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309


int evaluate_reference_basis_derivatives_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(double* restrict reference_values,
    int order, int num_points, const double* restrict X);

void compute_jacobians_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict J, int num_points,
                                      const double* restrict X,
                                      const double* restrict coordinate_dofs)
{
double dphi[12];
for (int l = 0; l < (num_points * 3) * 3; ++l)
    J[l] = 0.0;
for (int ip = 0; ip < num_points; ++ip)
{
    // Compute basis derivatives of coordinate element
    evaluate_reference_basis_derivatives_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(dphi, 1, 1, &X[3 * ip]);
    // Compute J
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            for (int d = 0; d < 4; ++d)
                J[((3 * 3) * ip + 3 * i) + j] += coordinate_dofs[3 * d + i] * dphi[3 * d + j];
}
}

void compute_jacobian_determinants_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict detJ, int num_points,
                                                  const double* restrict J)
{
for (int ip = 0; ip < num_points; ++ip)
    detJ[ip] = (J[(3 * 3) * ip] * (J[((3 * 3) * ip + 3) + 1] * J[((3 * 3) * ip + 3 * 2) + 2] - J[((3 * 3) * ip + 3) + 2] * J[((3 * 3) * ip + 3 * 2) + 1]) + J[(3 * 3) * ip + 1] * (J[((3 * 3) * ip + 3) + 2] * J[(3 * 3) * ip + 3 * 2] - J[(3 * 3) * ip + 3] * J[((3 * 3) * ip + 3 * 2) + 2])) + J[(3 * 3) * ip + 2] * (J[(3 * 3) * ip + 3] * J[((3 * 3) * ip + 3 * 2) + 1] - J[((3 * 3) * ip + 3) + 1] * J[(3 * 3) * ip + 3 * 2]);
}

void compute_jacobian_inverses_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict K, int num_points,
    const double* restrict J, const double* restrict detJ)
{
for (int ip = 0; ip < num_points; ++ip)
{
    K[(3 * 3) * ip] = (J[((3 * 3) * ip + 3 * 2) + 2] * J[((3 * 3) * ip + 3) + 1] - J[((3 * 3) * ip + 3) + 2] * J[((3 * 3) * ip + 3 * 2) + 1]) / detJ[ip];
    K[(3 * 3) * ip + 1] = (J[(3 * 3) * ip + 2] * J[((3 * 3) * ip + 3 * 2) + 1] - J[(3 * 3) * ip + 1] * J[((3 * 3) * ip + 3 * 2) + 2]) / detJ[ip];
    K[(3 * 3) * ip + 2] = (J[(3 * 3) * ip + 1] * J[((3 * 3) * ip + 3) + 2] - J[(3 * 3) * ip + 2] * J[((3 * 3) * ip + 3) + 1]) / detJ[ip];
    K[(3 * 3) * ip + 3] = (J[((3 * 3) * ip + 3) + 2] * J[(3 * 3) * ip + 3 * 2] - J[((3 * 3) * ip + 3 * 2) + 2] * J[(3 * 3) * ip + 3]) / detJ[ip];
    K[((3 * 3) * ip + 3) + 1] = (J[((3 * 3) * ip + 3 * 2) + 2] * J[(3 * 3) * ip] - J[(3 * 3) * ip + 2] * J[(3 * 3) * ip + 3 * 2]) / detJ[ip];
    K[((3 * 3) * ip + 3) + 2] = (J[(3 * 3) * ip + 2] * J[(3 * 3) * ip + 3] - J[((3 * 3) * ip + 3) + 2] * J[(3 * 3) * ip]) / detJ[ip];
    K[(3 * 3) * ip + 3 * 2] = (J[(3 * 3) * ip + 3] * J[((3 * 3) * ip + 3 * 2) + 1] - J[(3 * 3) * ip + 3 * 2] * J[((3 * 3) * ip + 3) + 1]) / detJ[ip];
    K[((3 * 3) * ip + 3 * 2) + 1] = (J[(3 * 3) * ip + 1] * J[(3 * 3) * ip + 3 * 2] - J[(3 * 3) * ip] * J[((3 * 3) * ip + 3 * 2) + 1]) / detJ[ip];
    K[((3 * 3) * ip + 3 * 2) + 2] = (J[(3 * 3) * ip] * J[((3 * 3) * ip + 3) + 1] - J[(3 * 3) * ip + 1] * J[(3 * 3) * ip + 3]) / detJ[ip];
}
}


int evaluate_reference_basis_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(double* restrict reference_values,
    int num_points, const double* restrict X);

void compute_physical_coordinates_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict x, int num_points,
                                                 const double* restrict X,
                                                 const double* restrict coordinate_dofs)
{
double phi[4];
for (int i = 0; i < num_points * 3; ++i)
    x[i] = 0.0;
for (int ip = 0; ip < num_points; ++ip)
{
    // Compute basis values of coordinate element
    evaluate_reference_basis_element_e62ea130829c4611b756de2cbd7d0ee4b144b528(phi, 1, &X[3 * ip]);
    // Compute x
    for (int i = 0; i < 3; ++i)
        for (int d = 0; d < 4; ++d)
            x[3 * ip + i] += coordinate_dofs[3 * d + i] * phi[d];
}
for (int ip = 0; ip < num_points; ++ip)
{
    for (int i = 0; i < 3; ++i)
    {
        if (fabs(x[3 * ip + i]) < 1e-16)
        {
            x[3 * ip + i] = 0.0;
        }
    }
}
}

void compute_geometry_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict x, double* restrict J,
                                     double* restrict detJ, double* restrict K,
                                     int num_points, const double* restrict X,
                                     const double* restrict coordinate_dofs)
{
compute_physical_coordinates_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(x, num_points, X, coordinate_dofs);
compute_jacobians_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(J, num_points, X, coordinate_dofs);
compute_jacobian_determinants_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(detJ, num_points, J);
compute_jacobian_inverses_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(K, num_points, J, detJ);
}

void compute_midpoint_geometry_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict x, double* restrict J,
                                              const double* restrict coordinate_dofs)
{
const double phi_Xm[4] = { 0.25000000000000006, 0.24999999999999997, 0.25, 0.25 };
const double dphi_Xm[3][4] =
    { { -1.0, 1.0, 0.0, 0.0 },
      { -1.0, 0.0, 1.0, 0.0 },
      { -1.0, 0.0, 0.0, 1.0 } };
for (int l = 0; l < 9; ++l)
    J[l] = 0.0;
// Compute x
for (int i = 0; i < 3; ++i)
{
    x[i] = 0.0;
    for (int d = 0; d < 4; ++d)
        x[i] += coordinate_dofs[3 * d + i] * phi_Xm[d];
}
// Compute J
for (int i = 0; i < 3; ++i)
    for (int j = 0; j < 3; ++j)
        for (int d = 0; d < 4; ++d)
            J[3 * i + j] += coordinate_dofs[3 * d + i] * dphi_Xm[j][d];
}

void compute_reference_coordinates_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict X, int num_points,
                                                  const double* restrict x,
                                                  const double* restrict coordinate_dofs)
{
for (int l = 0; l < num_points * 3; ++l)
    X[l] = 0.0;
const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
const double dphi_X0[3][4] =
    { { -1.0, 1.0, 0.0, 0.0 },
      { -1.0, 0.0, 1.0, 0.0 },
      { -1.0, 0.0, 0.0, 1.0 } };
double J[9];
double detJ[1];
double K[9];
double x0[3] = { 0 };
for (int i = 0; i < 3; ++i)
    for (int k = 0; k < 4; ++k)
        x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
for (int i = 0; i < 3; ++i)
{
    for (int j = 0; j < 3; ++j)
    {
        J[3 * i + j] = 0.0;
        for (int k = 0; k < 4; ++k)
            J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(detJ, 1, J);
compute_jacobian_inverses_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(K, 1, J, detJ);
for (int ip = 0; ip < num_points; ++ip)
    for (int j = 0; j < 3; ++j)
        for (int i = 0; i < 3; ++i)
            X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void compute_reference_geometry_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(double* restrict X, double* restrict J,
                                               double* restrict detJ, double* restrict K,
                                               int num_points, const double* restrict x,
                                               const double* restrict coordinate_dofs)
{
for (int l = 0; l < num_points * 3; ++l)
    X[l] = 0.0;
const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
const double dphi_X0[3][4] =
    { { -1.0, 1.0, 0.0, 0.0 },
      { -1.0, 0.0, 1.0, 0.0 },
      { -1.0, 0.0, 0.0, 1.0 } };
double x0[3] = { 0 };
for (int i = 0; i < 3; ++i)
    for (int k = 0; k < 4; ++k)
        x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
for (int i = 0; i < 3; ++i)
{
    for (int j = 0; j < 3; ++j)
    {
        J[3 * i + j] = 0.0;
        for (int k = 0; k < 4; ++k)
            J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(detJ, 1, J);
compute_jacobian_inverses_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(K, 1, J, detJ);
for (int ip = 0; ip < num_points; ++ip)
    for (int j = 0; j < 3; ++j)
        for (int i = 0; i < 3; ++i)
            X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

ufc_coordinate_mapping* create_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(void)
{
  ufc_coordinate_mapping* cmap = malloc(sizeof(*cmap));
  cmap->signature = "FFCX coordinate_mapping from VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  cmap->create = create_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->geometric_dimension = 3;
  cmap->topological_dimension = 3;
  cmap->cell_shape = tetrahedron;
  cmap->create_scalar_dofmap = create_dofmap_e62ea130829c4611b756de2cbd7d0ee4b144b528;
  cmap->compute_physical_coordinates = compute_physical_coordinates_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_reference_coordinates = compute_reference_coordinates_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_reference_geometry = compute_reference_geometry_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_jacobians = compute_jacobians_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_jacobian_determinants = compute_jacobian_determinants_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_jacobian_inverses = compute_jacobian_inverses_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_geometry = compute_geometry_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  cmap->compute_midpoint_geometry = compute_midpoint_geometry_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
  return cmap;
}

ufc_coordinate_mapping* create_coordinate_map_test(void)
{
  return create_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309();
}


// End of code for coordinate mapping coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309

// Code for integral integral_cell_otherwise_d43e3c3b1a9850b316c767c17c458fba4fe92f87


void tabulate_tensor_integral_cell_otherwise_d43e3c3b1a9850b316c767c17c458fba4fe92f87(ufc_scalar_t* restrict A,
                                    const ufc_scalar_t* restrict w,
                                    const ufc_scalar_t* restrict c,
                                    const double* restrict coordinate_dofs,
                                    const int* restrict unused_local_index,
                                    const uint8_t* restrict quadrature_permutation,
                                    const uint32_t cell_permutation)
{
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.04166666666666666, 0.04166666666666666, 0.04166666666666666, 0.04166666666666666 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [permutation][entities][points][dofs]
    alignas(32) static const double FE12_C0_D001_Q4[1][1][1][4] = { { { { -1.0, 0.0, 0.0, 1.0 } } } };
    alignas(32) static const double FE12_C0_D010_Q4[1][1][1][3] = { { { { -1.0, 0.0, 1.0 } } } };
    alignas(32) static const double FE12_C0_D100_Q4[1][1][1][2] = { { { { -1.0, 1.0 } } } };
    alignas(32) static const double FE12_C0_Q4[1][1][4][4] =
        { { { { 0.1381966011250091, 0.585410196624969, 0.138196601125011, 0.138196601125011 },
              { 0.1381966011250091, 0.1381966011250109, 0.585410196624969, 0.138196601125011 },
              { 0.1381966011250091, 0.1381966011250109, 0.138196601125011, 0.585410196624969 },
              { 0.5854101966249672, 0.1381966011250109, 0.138196601125011, 0.138196601125011 } } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE12_C0_D100_Q4[0][0][0][0] + coordinate_dofs[3] * FE12_C0_D100_Q4[0][0][0][1];
    const double J_c4 = coordinate_dofs[1] * FE12_C0_D010_Q4[0][0][0][0] + coordinate_dofs[4] * FE12_C0_D010_Q4[0][0][0][1] + coordinate_dofs[7] * FE12_C0_D010_Q4[0][0][0][2];
    const double J_c8 = coordinate_dofs[2] * FE12_C0_D001_Q4[0][0][0][0] + coordinate_dofs[5] * FE12_C0_D001_Q4[0][0][0][1] + coordinate_dofs[8] * FE12_C0_D001_Q4[0][0][0][2] + coordinate_dofs[11] * FE12_C0_D001_Q4[0][0][0][3];
    const double J_c5 = coordinate_dofs[1] * FE12_C0_D001_Q4[0][0][0][0] + coordinate_dofs[4] * FE12_C0_D001_Q4[0][0][0][1] + coordinate_dofs[7] * FE12_C0_D001_Q4[0][0][0][2] + coordinate_dofs[10] * FE12_C0_D001_Q4[0][0][0][3];
    const double J_c7 = coordinate_dofs[2] * FE12_C0_D010_Q4[0][0][0][0] + coordinate_dofs[5] * FE12_C0_D010_Q4[0][0][0][1] + coordinate_dofs[8] * FE12_C0_D010_Q4[0][0][0][2];
    const double J_c1 = coordinate_dofs[0] * FE12_C0_D010_Q4[0][0][0][0] + coordinate_dofs[3] * FE12_C0_D010_Q4[0][0][0][1] + coordinate_dofs[6] * FE12_C0_D010_Q4[0][0][0][2];
    const double J_c6 = coordinate_dofs[2] * FE12_C0_D100_Q4[0][0][0][0] + coordinate_dofs[5] * FE12_C0_D100_Q4[0][0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE12_C0_D100_Q4[0][0][0][0] + coordinate_dofs[4] * FE12_C0_D100_Q4[0][0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE12_C0_D001_Q4[0][0][0][0] + coordinate_dofs[3] * FE12_C0_D001_Q4[0][0][0][1] + coordinate_dofs[6] * FE12_C0_D001_Q4[0][0][0][2] + coordinate_dofs[9] * FE12_C0_D001_Q4[0][0][0][3];
    alignas(32) ufc_scalar_t sp[15];
    sp[0] = J_c4 * J_c8;
    sp[1] = J_c5 * J_c7;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 * sp[2];
    sp[4] = J_c5 * J_c6;
    sp[5] = J_c3 * J_c8;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = J_c1 * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c3 * J_c7;
    sp[10] = J_c4 * J_c6;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = J_c2 * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = fabs(sp[13]);
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        ufc_scalar_t w0_c0 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_c0 += w[ic] * FE12_C0_Q4[0][0][iq][ic];
        ufc_scalar_t w0_c1 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_c1 += w[ic + 4] * FE12_C0_Q4[0][0][iq][ic];
        ufc_scalar_t w0_c2 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_c2 += w[ic + 8] * FE12_C0_Q4[0][0][iq][ic];
        alignas(32) ufc_scalar_t sv4[6];
        sv4[0] = w0_c0 * w0_c0;
        sv4[1] = w0_c1 * w0_c1;
        sv4[2] = sv4[0] + sv4[1];
        sv4[3] = w0_c2 * w0_c2;
        sv4[4] = sv4[2] + sv4[3];
        sv4[5] = sv4[4] * sp[14];
        const ufc_scalar_t fw0 = sv4[5] * weights4[iq];
        A[0] += fw0;
    }
}


ufc_integral* create_integral_cell_otherwise_d43e3c3b1a9850b316c767c17c458fba4fe92f87(void)
{
  static const bool enabled[1] = { true };
  ufc_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_integral_cell_otherwise_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  return integral;
}

// End of code for integral integral_cell_otherwise_d43e3c3b1a9850b316c767c17c458fba4fe92f87

// Code for form form_d43e3c3b1a9850b316c767c17c458fba4fe92f87

int original_coefficient_position_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int i)
{
if (i >= 1)
{
    // Invalid original coefficient index.
    return -1;
}
static const int position[1] = { 0 };
return position[i];
}

// Return a list of the coefficient names.
const char** coefficient_name_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(void)
{
static const char* names[1] = { "u" };
return names;
}

// Return a list of the constant names.
const char** constant_name_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(void)
{
return NULL;
}

ufc_coordinate_mapping* create_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309(void);

ufc_coordinate_mapping* create_coordinate_mapping_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(void)
{
return create_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309();
}

ufc_finite_element* create_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(void);

ufc_finite_element* create_finite_element_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int i)
{
switch (i)
{
case 0:
    return create_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f();
default:
    return NULL;
}
}

ufc_dofmap* create_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f(void);

ufc_dofmap* create_dofmap_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int i)
{
switch (i)
{
case 0:
    return create_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f();
default:
    return NULL;
}
}

ufc_integral* create_cell_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_integral_cell_otherwise_d43e3c3b1a9850b316c767c17c458fba4fe92f87();
default:
    return NULL;
}
}

void get_cell_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int *ids)
{
  ids[0] = -1;
return;
}

ufc_integral* create_exterior_facet_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int subdomain_id)
{
  return NULL;
}

void get_exterior_facet_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int *ids)
{
  return;
}

ufc_integral* create_interior_facet_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int subdomain_id)
{
return NULL;
}

void get_interior_facet_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int *ids)
{
  return;
}

ufc_integral* create_vertex_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int subdomain_id)
{
return NULL;
}

void get_vertex_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int *ids)
{
  return;
}

ufc_custom_integral* create_custom_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int subdomain_id)
{
return NULL;
}

void get_custom_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(int *ids)
{
  return;
}

ufc_form* create_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87(void)
{
  ufc_form* form = malloc(sizeof(*form));

  form->signature = "6d607153dc6c6c50a86a22fc352b6c79ba4cab9e931dbbf9a8673e1983dc51d521e15cd584d6f2ab8c606d348397fbf937538f1a4bf380393d676b7438952b07";
  form->rank = 0;
  form->num_coefficients = 1;
  form->num_constants = 0;
  form->original_coefficient_position = original_coefficient_position_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;

  form->coefficient_name_map = coefficient_name_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->constant_name_map = constant_name_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;

  form->create_coordinate_mapping = create_coordinate_mapping_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->create_finite_element = create_finite_element_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->create_dofmap = create_dofmap_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;

  form->get_cell_integral_ids = get_cell_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->get_exterior_facet_integral_ids = get_exterior_facet_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->get_interior_facet_integral_ids = get_interior_facet_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->get_vertex_integral_ids = get_vertex_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->get_custom_integral_ids = get_custom_integral_ids_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;

  form->num_cell_integrals = 1;
  form->num_exterior_facet_integrals = 0;
  form->num_interior_facet_integrals = 0;
  form->num_vertex_integrals = 0;
  form->num_custom_integrals = 0;

  form->create_cell_integral = create_cell_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->create_exterior_facet_integral = create_exterior_facet_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->create_interior_facet_integral = create_interior_facet_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->create_vertex_integral = create_vertex_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;
  form->create_custom_integral = create_custom_integral_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87;

  return form;
}

ufc_form* create_form_test_a(void)
{
  return create_form_d43e3c3b1a9850b316c767c17c458fba4fe92f87();
}

ufc_function_space* create_functionspace_form_test_a(const char* function_name)
{
  if (strcmp(function_name, "u") == 0)
{
    ufc_function_space* space = (ufc_function_space*) malloc(sizeof(*space));
    space->create_element = create_element_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
    space->create_dofmap = create_dofmap_57d632e6da5498ea9b99ecb0a2b64ad86741db6f;
    space->create_coordinate_mapping = create_coordinate_mapping_c1881447d6b8c072bffeb3eb309b78481eb4d309;
    return space;
}
return NULL;

}

// End of code for form form_d43e3c3b1a9850b316c767c17c458fba4fe92f87
